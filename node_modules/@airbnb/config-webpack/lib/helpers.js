"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fast_glob_1 = __importDefault(require("fast-glob"));
const core_1 = require("@beemo/core");
const nimbus_common_1 = require("@airbnb/nimbus-common");
const { WEBPACK_ESM_SCOPES, WEBPACK_ESM_PACKAGES } = process.env;
exports.ROOT = process.cwd();
exports.PROD = process.env.NODE_ENV === 'production';
exports.PORT = 8081;
const esmScopes = ['@airbnb', '@irbnb'];
const esmPackages = [
    'aesthetic',
    'aesthetic-*',
    'airbnb-*',
    'emojibase',
    'emojibase-*',
    'interweave',
    'interweave-*',
    'lodash-es',
    'optimal',
    'shapeshifter',
    'shapeshifter-*',
];
if (WEBPACK_ESM_SCOPES) {
    esmScopes.push(...WEBPACK_ESM_SCOPES.split(','));
}
if (WEBPACK_ESM_PACKAGES) {
    esmPackages.push(...WEBPACK_ESM_PACKAGES.split(','));
}
function getESMAliases() {
    const aliases = {};
    const pkg = nimbus_common_1.getPackage();
    const buildTargets = ['lib', 'build', 'dist'];
    fast_glob_1.default
        .sync([`node_modules/{${esmScopes.join(',')}}/*`, `node_modules/{${esmPackages.join(',')}}`], {
        absolute: true,
        cwd: exports.ROOT,
        onlyDirectories: true,
        onlyFiles: false,
    })
        .forEach((modulePath) => {
        const packageName = modulePath.split('/node_modules/')[1];
        const esLessName = packageName.replace(/-es$/, '');
        const esPath = new core_1.Path(modulePath, 'es');
        const esmPath = new core_1.Path(modulePath, 'esm');
        // airbnb-foo/lib -> airbnb-foo/esm
        // optimal/lib -> optimal/esm
        if (esPath.exists() || esmPath.exists()) {
            const aliasPath = esPath.exists() ? `${packageName}/es` : `${packageName}/esm`;
            const aliased = buildTargets.some((targetFolder) => {
                if (new core_1.Path(modulePath, targetFolder).exists()) {
                    aliases[`${packageName}/${targetFolder}`] = aliasPath;
                    return true;
                }
                return false;
            });
            if (!aliased) {
                aliases[`${packageName}$`] = aliasPath;
            }
            // lodash -> lodash-es
        }
        else if (packageName.endsWith('-es') && pkg.dependencies && pkg.dependencies[esLessName]) {
            aliases[esLessName] = packageName;
        }
    });
    return aliases;
}
exports.getESMAliases = getESMAliases;
let favicon = '';
function getFavIcon(srcPath) {
    if (favicon) {
        return favicon;
    }
    const prodPath = new core_1.Path(srcPath, 'favicon.png');
    const devPath = new core_1.Path(srcPath, 'favicon-dev.png');
    if (!exports.PROD && devPath.exists()) {
        favicon = devPath.path();
    }
    else if (prodPath.exists()) {
        favicon = prodPath.path();
    }
    return favicon;
}
exports.getFavIcon = getFavIcon;
function getParallelValue(value) {
    if (value === undefined) {
        return true;
    }
    if (value === 'true') {
        return true;
    }
    if (value === 'false' || value === '') {
        return false;
    }
    return Number(value || 1);
}
exports.getParallelValue = getParallelValue;

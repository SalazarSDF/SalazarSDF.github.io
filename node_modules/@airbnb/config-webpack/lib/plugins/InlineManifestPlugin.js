"use strict";
/* eslint-disable no-param-reassign, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access, import/no-extraneous-dependencies */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const html_webpack_plugin_1 = __importDefault(require("html-webpack-plugin"));
const source_map_url_1 = __importDefault(require("source-map-url"));
function getAssetName(chunks, chunkName) {
    var _a, _b;
    return (_b = (_a = chunks.filter((chunk) => chunk.name === chunkName)) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.files[0];
}
function inlineWhenMatched(compilation, scripts, manifestAssetName) {
    return scripts.map((script) => {
        var _a;
        const isManifestScript = script.tagName === 'script' &&
            typeof script.attributes.src === 'string' && ((_a = script.attributes.src) === null || _a === void 0 ? void 0 : _a.includes(manifestAssetName));
        if (isManifestScript) {
            return {
                tagName: 'script',
                voidTag: false,
                attributes: {
                    type: 'text/javascript',
                },
                innerHTML: source_map_url_1.default.removeFrom(compilation.assets[manifestAssetName].source()),
            };
        }
        return script;
    });
}
class InlineManifestPlugin {
    constructor(name = 'runtime') {
        this.name = name;
    }
    apply(compiler) {
        const { name } = this;
        compiler.hooks.emit.tap('InlineManifestWebpackPlugin', (compilation) => {
            const assetName = getAssetName(compilation.chunks, name);
            if (assetName) {
                delete compilation.assets[assetName];
            }
        });
        compiler.hooks.compilation.tap('InlineManifestWebpackPlugin', (compilation) => {
            const hooks = html_webpack_plugin_1.default.getHooks(compilation);
            hooks.alterAssetTags.tapAsync('InlineManifestWebpackPlugin', (data, cb) => {
                const assetName = getAssetName(compilation.chunks, name);
                if (assetName) {
                    data.assetTags.scripts = inlineWhenMatched(compilation, data.assetTags.scripts, assetName);
                }
                cb(null, data);
            });
            hooks.beforeAssetTagGeneration.tapAsync('InlineManifestWebpackPlugin', (htmlPluginData, cb) => {
                const assetName = getAssetName(compilation.chunks, name);
                // @ts-ignore Option exists
                if (assetName && htmlPluginData.plugin.options.inject === false) {
                    const { assets } = htmlPluginData;
                    const runtime = `<script>${source_map_url_1.default.removeFrom(compilation.assets[assetName].source())}</script>`;
                    const runtimeIndex = assets.js.indexOf(assets.publicPath + assetName);
                    if (runtimeIndex >= 0) {
                        assets.js.splice(runtimeIndex, 1);
                    }
                    assets.js.push(runtime);
                }
                cb(null, htmlPluginData);
            });
        });
    }
}
exports.default = InlineManifestPlugin;
